/*
   Copyright The Overlaybd Authors

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <zlib.h>
#include <gtest/gtest.h>
#include <fcntl.h>
#include <photon/photon.h>
#include <photon/fs/localfs.h>
#include <photon/fs/subfs.h>
#include <photon/fs/extfs/extfs.h>
#include <photon/common/alog.h>
#include <photon/common/alog-stdstring.h>
#include <vector>
#include <dirent.h>
#include "../../../gzindex/gzfile.h"
#include "../../../lsmt/file.h"
#include "../liberofs.h"
#include "../../tar_file.cpp"
#include "../../../gzip/gz.h"
#include "../../../../tools/sha256file.h"
#include "../../../../tools/comm_func.h"


#define FILE_SIZE (2 * 1024 * 1024)
#define IMAGE_SIZE 512UL<<20
class ErofsTest : public ::testing::Test {
public:
    static int inflate(std::string output_file, unsigned char *data, unsigned int size) {
        unsigned char out[65536];
        z_stream strm;
        int ret;
	/* allocate inflate state */
        strm.zalloc = Z_NULL;
        strm.zfree = Z_NULL;
        strm.opaque = Z_NULL;
        strm.avail_in = 0;
        strm.next_in = Z_NULL;
        ret = inflateInit2(&strm, 31);
        if (ret != Z_OK)
           return ret;
        DEFER((void)inflateEnd(&strm));
        strm.avail_in = size;
        strm.next_in = data;
        int fd = open(output_file.c_str(), O_WRONLY | O_TRUNC | O_CREAT, 0644);
        if (fd < 0)
	   return fd;
	DEFER(close(fd));
        do {
           strm.avail_out = sizeof(out);
           strm.next_out = out;
           ret = ::inflate(&strm, Z_NO_FLUSH);
           switch (ret) {
            case Z_NEED_DICT:
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                return -1;
            }
            int have = sizeof(out) - strm.avail_out;
            if (write(fd, out, have) != have) {
                return -1;
            }
        } while (strm.avail_out == 0);
        return 0;
    }

protected:
    virtual void SetUp() override{
        fs = photon::fs::new_localfs_adaptor();

        ASSERT_NE(nullptr, fs);
        if (fs->access(workdir.c_str(), 0) != 0) {
            auto ret = fs->mkdir(workdir.c_str(), 0755);
            ASSERT_EQ(0, ret);
        }

        fs = photon::fs::new_subfs(fs, workdir.c_str(), true);
        ASSERT_NE(nullptr, fs);
    }
    virtual void TearDown() override{
        for (auto fn : filelist){
            fs->unlink(fn.c_str());
        }
        if (fs)
            delete fs;
    }

    int download(const std::string &url, std::string out = "") {
        if (out == "") {
            out = workdir + "/" + std::string(basename(url.c_str()));
        }
        if (fs->access(out.c_str(), 0) == 0)
            return 0;
        // download file
        std::string cmd = "curl -s -o " + out + " " + url;
        LOG_INFO(VALUE(cmd.c_str()));
        auto ret = system(cmd.c_str());
        if (ret != 0) {
            LOG_ERRNO_RETURN(0, -1, "download failed: `", url.c_str());
        }
        return 0;
    }

    int download_decomp(const std::string &url) {
        // download file
        std::string cmd = "wget -q -O - " + url +" | gzip -d -c >" +
                          workdir + "/test.tar";
        LOG_INFO(VALUE(cmd.c_str()));
        auto ret = system(cmd.c_str());
        if (ret != 0) {
            LOG_ERRNO_RETURN(0, -1, "download failed: `", url.c_str());
        }
        return 0;
    }

    int write_file(photon::fs::IFile *file) {
        std::string bb = "abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01";
        ssize_t size = 0;
        ssize_t ret;
        struct stat st;
        LOG_INFO(VALUE(bb.size()));
        while (size < FILE_SIZE) {
            ret = file->write(bb.data(), bb.size());
            EXPECT_EQ(bb.size(), ret);
            ret = file->fstat(&st);
            EXPECT_EQ(0, ret);
            ret = file->lseek(0, SEEK_CUR);
            EXPECT_EQ(st.st_size, ret);
            size += bb.size();
        }
        LOG_INFO("write ` byte", size);
        EXPECT_EQ(FILE_SIZE, size);
        return 0;
    }

    IFile *createDevice(const char *fn, IFile *target_file, size_t virtual_size = IMAGE_SIZE){
        auto fn_idx = std::string(fn)+".idx";
        auto fn_meta = std::string(fn)+".meta";
        DEFER({
            filelist.push_back(fn_idx);
            filelist.push_back(fn_meta);
        });
        auto fmeta = fs->open(fn_idx.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
        auto findex = fs->open(fn_meta.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
        LSMT::WarpFileArgs args(findex, fmeta, target_file);
        args.virtual_size = virtual_size;
        return create_warpfile(args, false);
    }

    int do_verify(IFile *verify, IFile *test, off_t offset = 0, ssize_t count = -1) {

        if (count == -1) {
            count = verify->lseek(0, SEEK_END);
            auto len = test->lseek(0, SEEK_END);
            if (count != len) {
                LOG_ERROR("check logical length failed");
                return -1;
            }
        }
        LOG_INFO("start verify, virtual size: `", count);

        ssize_t LEN = 1UL<<20;
        char vbuf[1UL<<20], tbuf[1UL<<20];
        // set_log_output_level(0);
        for (off_t i = 0; i < count; i+=LEN) {
            LOG_DEBUG("`", i);
            auto ret_v = verify->pread(vbuf, LEN, i);
            auto ret_t = test->pread(tbuf, LEN, i);
            if (ret_v == -1 || ret_t == -1) {
                LOG_ERROR_RETURN(0, -1, "pread(`,`) failed. (ret_v: `, ret_t: `)",
                    i, LEN, ret_v, ret_v);
            }
            if (ret_v != ret_t) {
                LOG_ERROR_RETURN(0, -1, "compare pread(`,`) return code failed. ret:` / `(expected)",
                    i, LEN, ret_t, ret_v);
            }
            if (memcmp(vbuf, tbuf, ret_v)!= 0){
                LOG_ERROR_RETURN(0, -1, "compare pread(`,`) buffer failed.", i, LEN);
            }
        }
        return 0;
    }

    std::string workdir = "/tmp/tar_test";
    photon::fs::IFileSystem *fs;
    std::vector<std::string> filelist;
};

TEST_F(ErofsTest, tar_meta) {
    unsigned char tar_zipped[249] = {
        0x1f, 0x8b, 0x08, 0x08, 0x7d, 0x06, 0x12, 0x67, 0x00, 0x03, 0x74,
        0x65, 0x73, 0x74, 0x2e, 0x74, 0x61, 0x72, 0x00, 0xed, 0xd7, 0x31,
        0x0e, 0xc2, 0x30, 0x0c, 0x85, 0xe1, 0xce, 0x9c, 0xa2, 0x47, 0x48,
        0x52, 0x27, 0x86, 0xe3, 0x14, 0xc4, 0x05, 0x68, 0xb8, 0x3f, 0x35,
        0xe9, 0xc0, 0xea, 0xc1, 0x2e, 0x92, 0xdf, 0xbf, 0x54, 0xea, 0xf2,
        0xb2, 0x7c, 0x52, 0xd2, 0x9f, 0x5b, 0x9f, 0x8c, 0x4b, 0x7b, 0x8d,
        0x48, 0xbe, 0x99, 0x6b, 0xfa, 0xfd, 0x1e, 0xd1, 0x94, 0x89, 0x13,
        0x51, 0xca, 0x39, 0xcb, 0xff, 0xd6, 0x5a, 0x99, 0xe6, 0x64, 0x7d,
        0x30, 0xe9, 0xbd, 0xf5, 0xf5, 0x35, 0xcf, 0x1e, 0x53, 0xff, 0xd8,
        0x7a, 0x7f, 0x5c, 0xce, 0x3e, 0x03, 0x3a, 0xaf, 0xbe, 0xfb, 0x2f,
        0xc6, 0x1b, 0x0a, 0xff, 0x85, 0x4b, 0x16, 0xff, 0x5c, 0x2b, 0xfc,
        0x7b, 0x04, 0xff, 0xb1, 0x13, 0xff, 0x8b, 0xf1, 0x86, 0xce, 0x3f,
        0x7f, 0xfd, 0x37, 0x82, 0x7f, 0x8f, 0xe0, 0x3f, 0x76, 0xe2, 0x9f,
        0x8c, 0x37, 0x54, 0xfe, 0x17, 0x1a, 0xfe, 0x17, 0xf8, 0xf7, 0x08,
        0xfe, 0x63, 0x27, 0xfe, 0xab, 0xf1, 0x86, 0xca, 0x3f, 0x8f, 0xfb,
        0x7f, 0xc3, 0xfd, 0xdf, 0x25, 0xf8, 0x8f, 0x9d, 0xf8, 0x6f, 0xc6,
        0x1b, 0x0a, 0xff, 0x4b, 0x2a, 0x65, 0xbc, 0xff, 0x71, 0xff, 0x77,
        0x09, 0xfe, 0x63, 0x27, 0xfe, 0xd9, 0x78, 0x43, 0xe7, 0x7f, 0xdc,
        0xff, 0x2b, 0xc3, 0xbf, 0x47, 0xf0, 0x1f, 0x3b, 0xf1, 0x7f, 0x35,
        0xde, 0x50, 0xf9, 0xdf, 0x1f, 0xfe, 0x78, 0xff, 0xfb, 0x05, 0xff,
        0xb1, 0x13, 0xff, 0x37, 0xe3, 0x0d, 0x8d, 0xff, 0x9c, 0x0f, 0xff,
        0x09, 0xfe, 0x3d, 0x82, 0x7f, 0x84, 0x10, 0x8a, 0xd9, 0x07, 0xbf,
        0x49, 0x1c, 0x0f, 0x00, 0x28, 0x00, 0x00
    };
    // set_log_output_level(0);
    ASSERT_EQ(0, ErofsTest::inflate(workdir + "/test.tar", tar_zipped, sizeof(tar_zipped)));

    auto src_file = fs->open("test.tar", O_RDONLY, 0666);
    ASSERT_NE(nullptr, src_file);
    DEFER(delete src_file);
    auto verify_dev = createDevice("verify", src_file);
    auto tar = new LibErofs(verify_dev, 4096, false);
    ASSERT_EQ(0, tar->extract_tar(src_file, true, true));
    delete tar;

    src_file->lseek(0, 0);

    auto tar_idx = fs->open("test.tar.meta", O_TRUNC | O_CREAT | O_RDWR, 0644);
    auto imgfile = createDevice("mock", src_file);
    DEFER(delete imgfile;);
    auto tar2 = new UnTar(src_file, nullptr, 0, 4096, nullptr, true);
    auto obj_count = tar2->dump_tar_headers(tar_idx);
    EXPECT_NE(-1, obj_count);
    LOG_INFO("objects count: `", obj_count);
    tar_idx->lseek(0,0);
    delete tar2;

    auto tar3 = new LibErofs(imgfile, 4096, true);
    ASSERT_EQ(0, tar3->extract_tar(tar_idx, true, true));
    delete tar3;
    EXPECT_EQ(0, do_verify(verify_dev, imgfile));
    delete tar_idx;
}

class ErofsPax : public ::testing::Test {
protected:
    photon::fs::IFileSystem *host_fs;
    std::string workdir = "/tmp/pax_test";
    std::string src_path = workdir + "/pax.tar";
    std::string fn_idx = workdir + "/index.idx";
    std::string fn_meta = workdir + "/erofs.fs.meta";
    std::string sha256_path = workdir + "/sha256";

    virtual void SetUp() override{
        ASSERT_EQ(0, prepare_host_fs());
    }

    virtual void TearDown() override{
        ASSERT_NE(nullptr, host_fs);
        if (host_fs->access(src_path.c_str(), 0) == 0) {
            ASSERT_EQ(0, host_fs->unlink(src_path.c_str()));
        }
        if (host_fs->access(fn_idx.c_str(), 0) == 0) {
            ASSERT_EQ(0, host_fs->unlink(fn_idx.c_str()));
        }
        if (host_fs->access(fn_meta.c_str(), 0) == 0) {
            ASSERT_EQ(0, host_fs->unlink(fn_meta.c_str()));
        }
        if (host_fs->access(sha256_path.c_str(), 0) == 0) {
            ASSERT_EQ(0, host_fs->unlink(sha256_path.c_str()));
        }
        delete host_fs;
    }

    int prepare_host_fs() {
        host_fs = photon::fs::new_localfs_adaptor();
        if (!host_fs)
            return -1;
        if (host_fs->access(workdir.c_str(), 0) != 0) {
            if (host_fs->mkdir(workdir.c_str(), 0755))
                return -1;
        }
        return 0;
    }
};

TEST_F(ErofsPax, pax_test) {

    static const unsigned char tar_zipped[3149] = {
        0x1f, 0x8b, 0x08, 0x08, 0x97, 0x59, 0x35, 0x67, 0x00, 0x03, 0x70, 0x61, 0x78, 0x2e, 0x74, 0x61,
        0x72, 0x00, 0xed, 0x9d, 0xdb, 0x72, 0xdb, 0x46, 0x12, 0x86, 0x7d, 0x9d, 0xa7, 0xf0, 0x0b, 0x88,
        0x9a, 0xf3, 0x00, 0x17, 0xbe, 0xd8, 0x8a, 0x53, 0xb1, 0xab, 0xe2, 0xda, 0xad, 0x24, 0x37, 0xb9,
        0x72, 0x0d, 0x0e, 0x94, 0x18, 0x8b, 0x87, 0x22, 0x21, 0xaf, 0x95, 0xa7, 0xdf, 0x01, 0x28, 0x99,
        0xc4, 0x90, 0xc4, 0x60, 0xc0, 0x41, 0x0b, 0xeb, 0xea, 0xef, 0x22, 0xb6, 0x25, 0x39, 0x6d, 0xe9,
        0x6f, 0xfc, 0xdd, 0x33, 0x98, 0xc3, 0xec, 0xf6, 0x3f, 0xe6, 0xdb, 0x87, 0xd2, 0x14, 0xe5, 0x76,
        0x37, 0xe3, 0x52, 0x72, 0x96, 0xb2, 0xdb, 0xf2, 0x9b, 0x59, 0x6e, 0x1e, 0xca, 0xcf, 0x85, 0xa9,
        0xcc, 0x9b, 0xeb, 0x21, 0x16, 0x25, 0x44, 0xf3, 0xab, 0xc5, 0xfd, 0x95, 0x50, 0xce, 0xde, 0x50,
        0xa1, 0xa9, 0xe0, 0x8c, 0x71, 0x66, 0x3f, 0x4e, 0xb9, 0xfd, 0xd3, 0x9b, 0xb7, 0xdf, 0x22, 0xc4,
        0xf6, 0xf2, 0xb8, 0xab, 0xcc, 0xd6, 0xfe, 0x53, 0x20, 0x62, 0x4d, 0x10, 0x4e, 0xde, 0x2e, 0xab,
        0xc5, 0xb2, 0x7c, 0x47, 0x35, 0xa7, 0x9c, 0x28, 0x4d, 0xc4, 0x8c, 0x8b, 0x54, 0xa7, 0x24, 0xa1,
        0xea, 0x27, 0xfb, 0x59, 0x73, 0xfa, 0xd9, 0xc4, 0x7e, 0x56, 0x27, 0xbc, 0xfe, 0x6c, 0x7e, 0xf9,
        0xef, 0xbe, 0xf6, 0x77, 0x86, 0xf4, 0x21, 0xf2, 0xa3, 0x7e, 0x96, 0x97, 0xe7, 0x5f, 0x32, 0xc5,
        0x08, 0xdb, 0x3f, 0xf7, 0xf4, 0xc5, 0x0f, 0x18, 0x6f, 0xbc, 0xa0, 0xfd, 0xfc, 0x4b, 0x26, 0xe5,
        0x9b, 0xb7, 0x20, 0xcf, 0xe4, 0xcb, 0xf3, 0x7f, 0xbf, 0x5e, 0xdd, 0xfd, 0x73, 0x5f, 0xae, 0x66,
        0x0f, 0xf7, 0xff, 0x9c, 0xff, 0x3a, 0xeb, 0x90, 0x1d, 0xff, 0x1f, 0xd7, 0xdc, 0xfe, 0x4f, 0x38,
        0xb6, 0x7f, 0x72, 0x3b, 0xfb, 0xfd, 0xfd, 0x08, 0x79, 0x70, 0xc1, 0xf7, 0x0f, 0xfe, 0x2f, 0xd8,
        0xf7, 0xdf, 0x37, 0x1f, 0xa7, 0x94, 0xa1, 0xff, 0xc3, 0x20, 0xd8, 0xdb, 0x3f, 0x7e, 0xfe, 0xf0,
        0xf1, 0xb7, 0xbf, 0x66, 0xdf, 0x4c, 0x55, 0x6d, 0x67, 0xd5, 0xd6, 0xfe, 0x40, 0xca, 0x62, 0xb6,
        0xfe, 0x5a, 0x6e, 0x1f, 0xcc, 0xd3, 0x6c, 0x59, 0x56, 0x26, 0x5f, 0x6f, 0x9e, 0xde, 0xfd, 0x24,
        0x55, 0xf7, 0x57, 0x6e, 0xcb, 0x62, 0xb1, 0x2d, 0xf3, 0xea, 0xdd, 0xed, 0xdc, 0xfe, 0xf6, 0xb6,
        0x78, 0x4e, 0x26, 0xac, 0x03, 0x93, 0x66, 0xa4, 0x47, 0xbe, 0x45, 0xe3, 0xff, 0xaa, 0xf1, 0x7b,
        0xaa, 0x25, 0x3d, 0xfe, 0xb5, 0x46, 0x12, 0xc1, 0xad, 0xff, 0x2b, 0xa6, 0xa8, 0xe2, 0x44, 0xb3,
        0xba, 0xff, 0xd3, 0x44, 0x01, 0xfb, 0xff, 0x32, 0x33, 0x4f, 0xab, 0x6a, 0xbd, 0xba, 0xf4, 0x75,
        0xbe, 0xcf, 0xff, 0x20, 0xfe, 0x7f, 0xbf, 0xd8, 0x55, 0xeb, 0xed, 0x53, 0xd4, 0x18, 0x7e, 0xff,
        0x97, 0x8e, 0xff, 0x33, 0xca, 0x04, 0xfa, 0x3f, 0x04, 0x01, 0xfe, 0x9f, 0x06, 0xfb, 0xff, 0x73,
        0x32, 0x61, 0x09, 0x98, 0x2e, 0x23, 0x3d, 0xf2, 0x2d, 0x1a, 0xff, 0xdf, 0x3f, 0xef, 0xe7, 0xfc,
        0x9f, 0xd4, 0x0f, 0x7b, 0xdb, 0xff, 0x85, 0xa4, 0x1a, 0xfd, 0x1f, 0x82, 0xdb, 0xd9, 0xdd, 0xa2,
        0x1a, 0x39, 0x46, 0xfd, 0xf3, 0xd0, 0x5a, 0x5e, 0xd4, 0x7f, 0x3f, 0xfe, 0xdb, 0xeb, 0x4f, 0xc5,
        0x7e, 0xfe, 0x47, 0xd9, 0xfa, 0x2f, 0x47, 0xfe, 0x77, 0x35, 0xa0, 0xfe, 0x8b, 0xaa, 0xdd, 0x04,
        0xfc, 0xfc, 0xef, 0x4f, 0x9f, 0x3e, 0xfe, 0xf9, 0xf9, 0x97, 0xf7, 0x1f, 0xff, 0xfc, 0xf4, 0xc7,
        0xaf, 0x11, 0x62, 0x78, 0xeb, 0xbf, 0xd4, 0x4e, 0xfd, 0xe7, 0x8c, 0x73, 0xac, 0xff, 0x10, 0xf4,
        0xaf, 0xff, 0x2a, 0xb8, 0xfe, 0xd7, 0x99, 0xd5, 0x4e, 0x26, 0xec, 0x04, 0xa6, 0xc6, 0x39, 0x95,
        0x62, 0xc7, 0xf0, 0x8c, 0xff, 0xea, 0x01, 0xe0, 0xc1, 0xff, 0xed, 0x83, 0x6f, 0x0d, 0x41, 0x71,
        0xe8, 0xf9, 0x3f, 0xf4, 0xff, 0x17, 0xff, 0xff, 0xf0, 0xcb, 0xbf, 0xde, 0x47, 0x8d, 0x11, 0x3e,
        0xfe, 0xb3, 0x09, 0x20, 0xd1, 0xff, 0x21, 0x18, 0x73, 0xfc, 0x57, 0x67, 0x56, 0x9d, 0x4c, 0xe8,
        0xfa, 0xd3, 0xe5, 0xa0, 0xd2, 0x78, 0x31, 0x7c, 0xfe, 0x4f, 0xb8, 0x7e, 0xf1, 0x7f, 0xa6, 0xb5,
        0xae, 0xc7, 0x7f, 0x8c, 0x12, 0xf4, 0x7f, 0x08, 0xf6, 0xfa, 0x67, 0x5b, 0xb3, 0xca, 0xef, 0xcb,
        0xae, 0xf7, 0x5b, 0x57, 0x10, 0x30, 0xfe, 0xa3, 0x9a, 0xb1, 0xfd, 0xfb, 0x3f, 0x8d, 0xe3, 0x3f,
        0x08, 0xce, 0xd4, 0xff, 0x7c, 0xbd, 0x9a, 0x2f, 0xee, 0x22, 0xc6, 0xf0, 0xd7, 0x7f, 0x77, 0xfc,
        0x67, 0x87, 0x7f, 0x38, 0xfe, 0x03, 0x21, 0x60, 0xfc, 0x47, 0x87, 0xd4, 0xff, 0x7d, 0x32, 0x61,
        0x07, 0x30, 0x55, 0x8e, 0x55, 0x1a, 0x2b, 0x86, 0x77, 0xfc, 0x47, 0xa5, 0x33, 0xff, 0x27, 0x34,
        0xc7, 0xf7, 0x7f, 0x20, 0x9c, 0xf1, 0xff, 0xa2, 0xdc, 0xe5, 0xdb, 0xc5, 0xa6, 0x5a, 0x5c, 0xfe,
        0x66, 0xc3, 0xf0, 0xfa, 0xbf, 0x14, 0x8e, 0xff, 0x73, 0x41, 0x34, 0xfa, 0x3f, 0x04, 0x01, 0xfe,
        0x1f, 0xbc, 0xfe, 0xa3, 0xce, 0xac, 0xa3, 0x64, 0xc2, 0x22, 0x30, 0x41, 0x4e, 0x54, 0x1a, 0x21,
        0x86, 0xcf, 0xff, 0x29, 0xa5, 0x4e, 0xff, 0xaf, 0x08, 0x8e, 0xff, 0x60, 0xd8, 0xeb, 0x7f, 0xbf,
        0x5e, 0x7f, 0x19, 0x69, 0xf0, 0xf7, 0x66, 0xc8, 0xf8, 0x4f, 0x28, 0xdb, 0x12, 0xe0, 0xf8, 0x0f,
        0x80, 0x23, 0xfd, 0xdb, 0x5d, 0x80, 0xd9, 0x6c, 0x1e, 0x9e, 0x36, 0xa6, 0xca, 0xef, 0x6f, 0x96,
        0xbb, 0xbb, 0xd9, 0xae, 0x59, 0x26, 0x3c, 0x2c, 0x86, 0xb7, 0xfe, 0x6b, 0xb7, 0xfe, 0x2b, 0x61,
        0xd3, 0x00, 0xeb, 0x3f, 0x00, 0xfd, 0xeb, 0x7f, 0xe2, 0xf9, 0xca, 0xf3, 0xf5, 0x7f, 0x9f, 0x59,
        0x67, 0x93, 0x09, 0xfb, 0x81, 0x09, 0xe0, 0x55, 0x29, 0x42, 0x0c, 0x9f, 0xff, 0xd7, 0x83, 0xbd,
        0x96, 0xff, 0x33, 0x4a, 0x04, 0xc5, 0xfa, 0x0f, 0xc1, 0x45, 0xff, 0xcf, 0xd7, 0xcb, 0xe5, 0xa2,
        0x8a, 0x92, 0x08, 0x7e, 0xff, 0x27, 0x8e, 0xff, 0x4b, 0x29, 0x70, 0xfd, 0x3f, 0x08, 0xfd, 0xfd,
        0x5f, 0x27, 0xc3, 0xfd, 0xff, 0x24, 0x99, 0xd0, 0xfb, 0x27, 0x42, 0xa7, 0x4a, 0x91, 0x62, 0x78,
        0xfc, 0x9f, 0x2a, 0xb7, 0xff, 0x67, 0xd6, 0x01, 0x38, 0xfa, 0x3f, 0x04, 0x17, 0xfd, 0x7f, 0xbe,
        0x5b, 0xae, 0x57, 0x8b, 0x6a, 0xbd, 0xbd, 0xf9, 0x6f, 0xdd, 0x11, 0x2c, 0xcd, 0x6a, 0x70, 0x52,
        0xf8, 0xfc, 0x9f, 0x11, 0xd7, 0xff, 0x35, 0xd3, 0x38, 0xff, 0x07, 0x42, 0x40, 0xff, 0x3f, 0x68,
        0xfe, 0x6f, 0x9f, 0x59, 0x17, 0x93, 0x09, 0xeb, 0xc0, 0x2b, 0xd3, 0x4b, 0xa5, 0x2b, 0x63, 0x74,
        0xfb, 0x3f, 0xa5, 0x44, 0x6a, 0xb7, 0xff, 0xd7, 0x0c, 0xdf, 0xff, 0x80, 0x70, 0xd1, 0xff, 0x37,
        0xeb, 0x5d, 0x75, 0xf3, 0xb8, 0x29, 0x4c, 0x55, 0x5e, 0x9b, 0x05, 0xfe, 0xfe, 0x9f, 0xba, 0xfd,
        0xbf, 0xc6, 0xf7, 0xff, 0x30, 0x04, 0xf4, 0xff, 0x83, 0xd6, 0xff, 0xed, 0x33, 0xeb, 0x34, 0x99,
        0xd0, 0xf8, 0xa7, 0x41, 0xb7, 0x4a, 0x71, 0x62, 0x78, 0xfa, 0x7f, 0xc2, 0xb4, 0x74, 0xfb, 0x7f,
        0x8e, 0xfd, 0x3f, 0x0c, 0x97, 0xfd, 0x7f, 0x5b, 0xde, 0x1c, 0x26, 0x04, 0x71, 0xfe, 0xff, 0x07,
        0x05, 0x66, 0xfe, 0xff, 0x6c, 0x32, 0x61, 0x09, 0x98, 0x00, 0x5e, 0x95, 0x22, 0xc4, 0xf0, 0xf9,
        0xbf, 0x92, 0xee, 0xfc, 0x0f, 0x25, 0x5c, 0xa0, 0xff, 0x43, 0xd0, 0xe9, 0xff, 0xfb, 0x09, 0x41,
        0x9c, 0xff, 0xff, 0x81, 0x81, 0x99, 0xff, 0x3f, 0x49, 0x26, 0xf4, 0xfe, 0x89, 0xd0, 0xa9, 0x52,
        0xa4, 0x18, 0x1e, 0xff, 0xe7, 0xf5, 0x64, 0xbf, 0x3b, 0xff, 0xaf, 0x70, 0xfd, 0x17, 0x08, 0x9d,
        0xfe, 0xbf, 0x2c, 0xb7, 0x77, 0x11, 0x52, 0xc2, 0xef, 0xff, 0xca, 0xed, 0xff, 0xeb, 0xe3, 0x02,
        0xd1, 0xff, 0x01, 0x08, 0xe8, 0xff, 0xc5, 0x75, 0xfe, 0x7f, 0x26, 0x99, 0xb0, 0x0a, 0xbc, 0x3a,
        0x3d, 0x54, 0xba, 0x3a, 0x86, 0xb7, 0xff, 0x17, 0x27, 0xfd, 0x3f, 0xc3, 0xf9, 0x1f, 0x18, 0x3a,
        0xfd, 0x7f, 0xf3, 0xb8, 0x8b, 0x31, 0x0c, 0xf4, 0xfa, 0xbf, 0x72, 0xfd, 0x5f, 0x32, 0x8e, 0xfb,
        0xff, 0x41, 0x08, 0xe8, 0xff, 0xaf, 0x78, 0xff, 0xeb, 0x24, 0x13, 0xfa, 0xfe, 0x64, 0xe8, 0x50,
        0x29, 0x5a, 0x0c, 0x8f, 0xff, 0x5b, 0xaf, 0x77, 0xd6, 0x7f, 0xda, 0x86, 0x10, 0xfd, 0x1f, 0x86,
        0x4e, 0xff, 0xdf, 0x96, 0x99, 0xd9, 0x5d, 0xff, 0x2e, 0xc8, 0xdf, 0xff, 0x9f, 0xce, 0xff, 0x50,
        0x9c, 0xff, 0x07, 0x01, 0x6e, 0xfe, 0xa7, 0x95, 0x4c, 0x58, 0x01, 0x26, 0x42, 0xa7, 0x4a, 0x91,
        0x62, 0x74, 0xfb, 0x3f, 0xa5, 0x42, 0xb0, 0x93, 0xf9, 0x1f, 0x8e, 0xeb, 0xff, 0x41, 0xf0, 0xf8,
        0x7f, 0x5e, 0x2e, 0xbe, 0xbe, 0xc6, 0xfa, 0x1f, 0xa5, 0x71, 0xfe, 0x07, 0x04, 0xa0, 0xf5, 0x3f,
        0x27, 0xc9, 0x84, 0x05, 0x60, 0x1a, 0x74, 0xab, 0x14, 0x27, 0x86, 0xa7, 0xff, 0xa7, 0xe4, 0x64,
        0xfe, 0x87, 0x70, 0x82, 0xfd, 0x3f, 0x08, 0x5d, 0xfe, 0xbf, 0x31, 0xdf, 0x5f, 0x08, 0x5d, 0xb5,
        0x29, 0xc4, 0xe7, 0xff, 0x67, 0xd6, 0xff, 0x53, 0x85, 0xeb, 0xff, 0x41, 0x80, 0x59, 0xff, 0x7f,
        0x31, 0x99, 0xb0, 0x0c, 0xbc, 0x32, 0xbd, 0x54, 0xba, 0x32, 0x86, 0xc7, 0xff, 0x99, 0x3e, 0x9c,
        0xff, 0xff, 0x32, 0xff, 0xaf, 0xf0, 0xfc, 0x7f, 0x18, 0x2e, 0xfb, 0xff, 0xe3, 0xee, 0xfe, 0xa6,
        0x5a, 0xdf, 0xe4, 0xf7, 0x65, 0xfe, 0x65, 0xfd, 0x08, 0xfd, 0xfe, 0x57, 0xe3, 0xfc, 0x3f, 0x08,
        0x40, 0xef, 0x7f, 0xcf, 0x27, 0x13, 0xba, 0xff, 0xab, 0xd3, 0x43, 0xa5, 0xab, 0x63, 0x78, 0xfc,
        0x5f, 0x72, 0x7e, 0xb2, 0xff, 0x8b, 0x53, 0x5c, 0xff, 0x09, 0xc2, 0x45, 0xff, 0x8f, 0xb8, 0x0f,
        0xc4, 0xeb, 0xff, 0xca, 0x5d, 0xff, 0x2f, 0xb4, 0xc4, 0xf9, 0x7f, 0x10, 0x02, 0xe6, 0x7f, 0xae,
        0xf0, 0x7f, 0xdc, 0xfa, 0x35, 0x55, 0x2e, 0xaa, 0x14, 0x31, 0x86, 0xc7, 0xff, 0x35, 0x25, 0xcc,
        0x7d, 0xff, 0xcb, 0x15, 0xfa, 0x3f, 0x08, 0x67, 0xce, 0x7f, 0x5d, 0xac, 0x8a, 0x32, 0xaa, 0xf5,
        0x7a, 0xfd, 0x5f, 0xb8, 0xfd, 0x3f, 0xa3, 0x38, 0xff, 0x0f, 0x43, 0xc0, 0xf9, 0xaf, 0x64, 0x88,
        0xff, 0x37, 0xc9, 0x84, 0x8e, 0x3f, 0x59, 0x8e, 0x54, 0x1a, 0x2d, 0x46, 0xfd, 0x50, 0x77, 0x9f,
        0xff, 0xad, 0x0e, 0xe7, 0x7f, 0xd3, 0xe6, 0xfe, 0x0f, 0x45, 0xf0, 0xfe, 0x27, 0x10, 0x5e, 0xf4,
        0x9f, 0xaf, 0xc7, 0x8b, 0xe1, 0xa9, 0xff, 0xcd, 0x8f, 0xcb, 0x39, 0xff, 0x55, 0x30, 0x3c, 0xff,
        0x15, 0x84, 0x83, 0xfe, 0xed, 0x26, 0xa0, 0xfc, 0x96, 0x3f, 0x3c, 0x16, 0x71, 0xba, 0x40, 0x6f,
        0xfd, 0x97, 0xee, 0xfd, 0x5f, 0x5c, 0x48, 0xdc, 0xff, 0x07, 0x42, 0x40, 0xfd, 0xd7, 0xc3, 0xea,
        0xbf, 0xcd, 0xac, 0xe7, 0x64, 0xc2, 0x36, 0x60, 0x7a, 0x9c, 0xaa, 0x14, 0x3f, 0x86, 0xaf, 0xfe,
        0x73, 0xe5, 0xfa, 0xbf, 0xaa, 0x8f, 0x84, 0xc2, 0xfa, 0x0f, 0xc0, 0x5e, 0xff, 0x87, 0xf5, 0xdd,
        0x78, 0xc7, 0xbf, 0x07, 0xd6, 0x7f, 0xde, 0xd4, 0x7f, 0x8e, 0xf7, 0x7f, 0x81, 0x70, 0xd0, 0x7f,
        0xbc, 0x4b, 0x40, 0xfd, 0xf5, 0x9f, 0xb9, 0xe3, 0x7f, 0xc9, 0x70, 0xfd, 0x07, 0x08, 0x01, 0xf5,
        0x7f, 0xd0, 0xfc, 0x6f, 0x93, 0x59, 0x78, 0x09, 0xe8, 0x64, 0x71, 0x54, 0x1a, 0x25, 0x86, 0xa7,
        0xfe, 0x53, 0xc2, 0xa4, 0x7b, 0xff, 0x33, 0xc5, 0xfb, 0x9f, 0x61, 0x38, 0xd2, 0x7f, 0x5b, 0xce,
        0xc7, 0x69, 0x02, 0xc2, 0xeb, 0xbf, 0xe4, 0x5a, 0x61, 0xfd, 0x87, 0xc0, 0xd1, 0xff, 0xf6, 0xde,
        0x76, 0x00, 0xb1, 0xb3, 0x20, 0x40, 0xff, 0xe7, 0xfb, 0x7f, 0x95, 0xa8, 0xe7, 0xff, 0x51, 0xff,
        0xf1, 0x39, 0xab, 0xbf, 0x73, 0x1f, 0xe0, 0x62, 0x3e, 0x2f, 0xb7, 0xe5, 0xaa, 0xba, 0x29, 0xca,
        0xcd, 0x90, 0xdc, 0xf0, 0xf6, 0x7f, 0xda, 0xbd, 0xff, 0x55, 0x69, 0x89, 0xfd, 0x1f, 0x08, 0x01,
        0xeb, 0xbf, 0xe4, 0xe0, 0xfe, 0xef, 0x28, 0xb3, 0xda, 0xc9, 0x84, 0x4d, 0xe1, 0x6b, 0xd3, 0x47,
        0xa5, 0x6b, 0x63, 0x78, 0xfa, 0x3f, 0x22, 0x19, 0x6f, 0xf7, 0x7f, 0x8c, 0x72, 0x3c, 0xff, 0x09,
        0x86, 0x1e, 0xfe, 0xbf, 0x34, 0x8b, 0xeb, 0x6e, 0x85, 0xf4, 0xfa, 0xbf, 0x72, 0xe7, 0xff, 0xa5,
        0xfd, 0x20, 0xfa, 0x3f, 0x04, 0x01, 0xeb, 0xbf, 0xa2, 0xf8, 0x7f, 0x9d, 0x4c, 0xe8, 0xfa, 0xd3,
        0xe1, 0xb2, 0x4a, 0xf1, 0x62, 0xf8, 0xfc, 0x9f, 0xb5, 0xee, 0x7f, 0xa8, 0xc7, 0x7f, 0x5a, 0xe0,
        0xfa, 0x5f, 0x18, 0x5c, 0xfd, 0xb7, 0xe5, 0x72, 0x5d, 0x95, 0x71, 0x47, 0x80, 0x01, 0xe3, 0xbf,
        0x17, 0xfd, 0x89, 0xc4, 0xf1, 0x1f, 0x08, 0x17, 0xf4, 0xbf, 0x5d, 0x6f, 0x17, 0x77, 0xb1, 0x3c,
        0x20, 0x40, 0x7f, 0x4e, 0x05, 0x69, 0xf6, 0xff, 0x72, 0x9c, 0xff, 0x01, 0xa1, 0x5b, 0xff, 0x38,
        0xef, 0x84, 0xbc, 0xfd, 0xdf, 0xe9, 0xfe, 0x2f, 0x81, 0xe7, 0x3f, 0xc3, 0x30, 0xf6, 0xfe, 0xaf,
        0x8b, 0x99, 0x85, 0xef, 0x84, 0x26, 0x41, 0x0f, 0x95, 0xae, 0x8e, 0x11, 0xdc, 0xff, 0x31, 0x4a,
        0xea, 0xfd, 0x3f, 0xd8, 0xff, 0x8d, 0x4f, 0x88, 0xff, 0x0f, 0x9d, 0x15, 0xf2, 0xf9, 0xbf, 0x95,
        0xbb, 0xed, 0xff, 0x8c, 0x28, 0x86, 0xeb, 0xff, 0x41, 0xe8, 0xef, 0xff, 0x69, 0x5c, 0xff, 0xc7,
        0x89, 0xe0, 0x49, 0x10, 0xa4, 0xd2, 0xc0, 0x18, 0x5e, 0xff, 0x3f, 0x9e, 0xff, 0x6d, 0xfa, 0x7f,
        0xce, 0xf0, 0xfe, 0x17, 0x18, 0xf6, 0xfa, 0xaf, 0xb3, 0xbf, 0xed, 0x93, 0x3b, 0xd6, 0x12, 0xc0,
        0xa0, 0xf1, 0xdf, 0xf3, 0xfa, 0x0f, 0x46, 0x71, 0xfc, 0x07, 0x41, 0x4b, 0xff, 0x5b, 0x9a, 0x8d,
        0x11, 0x23, 0x48, 0xff, 0x66, 0xff, 0x8f, 0xc4, 0xfd, 0x1f, 0x40, 0xb8, 0xfa, 0xb7, 0x3b, 0xbe,
        0x3c, 0x63, 0x86, 0x91, 0x92, 0x2a, 0x96, 0x65, 0x6a, 0x4e, 0x54, 0x91, 0x08, 0x25, 0x73, 0x6d,
        0xd2, 0x24, 0xa5, 0xa9, 0x26, 0xda, 0x24, 0x9c, 0x92, 0xdc, 0x17, 0xc3, 0xdb, 0xff, 0xd5, 0x3d,
        0x7f, 0xbb, 0xff, 0x23, 0x0a, 0xc7, 0xff, 0x20, 0xf4, 0xef, 0xff, 0xec, 0x98, 0x6c, 0x48, 0x03,
        0x78, 0x94, 0x5a, 0xfd, 0xb2, 0x09, 0x5b, 0x41, 0x48, 0x06, 0x8a, 0x14, 0x14, 0xa3, 0x7e, 0xa8,
        0x85, 0xb8, 0xdc, 0xff, 0xd5, 0xf7, 0x3f, 0xb4, 0xfc, 0x9f, 0x31, 0xa1, 0xf1, 0xfc, 0x47, 0x10,
        0xda, 0xfa, 0xcb, 0xf9, 0x18, 0x31, 0xc2, 0xea, 0xbf, 0x6c, 0xea, 0x7f, 0x7d, 0xff, 0x37, 0xd6,
        0xff, 0xf1, 0x71, 0xf5, 0x6f, 0xd7, 0x7f, 0x5e, 0xa6, 0xaa, 0x98, 0x67, 0x89, 0x4e, 0xb9, 0x10,
        0xda, 0xfe, 0x97, 0x66, 0x39, 0xd1, 0xb9, 0x31, 0x19, 0x31, 0x2a, 0x97, 0x5c, 0x32, 0x41, 0x4d,
        0xe2, 0x8b, 0x31, 0xa0, 0xfe, 0x53, 0xa9, 0xb0, 0xfe, 0x43, 0x00, 0x56, 0xff, 0x6d, 0x6a, 0xf5,
        0xcb, 0x26, 0xac, 0xff, 0x90, 0x0c, 0x14, 0x29, 0x28, 0x86, 0xa7, 0xfe, 0xd7, 0x4f, 0x7b, 0xdb,
        0xff, 0x19, 0x93, 0x0a, 0xcf, 0xff, 0x07, 0xa1, 0xad, 0x7f, 0x32, 0xca, 0xbf, 0x3b, 0xa4, 0xfe,
        0xdb, 0x74, 0x68, 0xf6, 0x7f, 0x08, 0xac, 0xff, 0x20, 0xb8, 0xfa, 0xb7, 0xeb, 0xbf, 0x4a, 0xcb,
        0x3c, 0x11, 0xb9, 0x9c, 0x6b, 0x96, 0x97, 0x65, 0x22, 0x13, 0x43, 0x64, 0x99, 0x25, 0xdc, 0x98,
        0xb4, 0xd0, 0x74, 0xae, 0x78, 0xfd, 0xc2, 0xce, 0xfb, 0xbd, 0x0e, 0xa9, 0xff, 0x1a, 0xcf, 0xff,
        0x03, 0x01, 0xac, 0xfe, 0x27, 0x7d, 0xb3, 0x09, 0xeb, 0x3f, 0x24, 0x03, 0x45, 0x0a, 0x8a, 0xd1,
        0x59, 0xff, 0xa9, 0x16, 0xca, 0xf5, 0x7f, 0xc6, 0x14, 0xc1, 0xf7, 0xff, 0x20, 0xb4, 0xf5, 0x4f,
        0x47, 0x29, 0xb9, 0x43, 0xea, 0xbf, 0xc4, 0xf7, 0x3f, 0x20, 0xb8, 0xfa, 0x3b, 0xf5, 0xdf, 0xe8,
        0x22, 0x17, 0x82, 0x29, 0x6e, 0xf5, 0xa3, 0x8a, 0x24, 0x24, 0x13, 0x2a, 0xa7, 0x05, 0xa5, 0x59,
        0x36, 0x9f, 0xcf, 0x13, 0x96, 0xa4, 0x5c, 0x6a, 0x5f, 0x8c, 0xe0, 0xfa, 0x4f, 0xb5, 0x35, 0x05,
        0xac, 0xff, 0x10, 0x80, 0xd5, 0x7f, 0x9b, 0x5a, 0xfd, 0xb2, 0x09, 0xeb, 0x3f, 0x24, 0x03, 0x45,
        0x0a, 0x8a, 0xd1, 0x59, 0xff, 0xeb, 0xf1, 0x3f, 0x63, 0x6e, 0xfd, 0xe7, 0x02, 0xeb, 0x3f, 0x08,
        0x8e, 0xfe, 0x61, 0xc2, 0xf6, 0x24, 0xa4, 0xfe, 0x3f, 0xcf, 0xff, 0x37, 0xfb, 0x3f, 0xb1, 0xfe,
        0x8f, 0x8f, 0xab, 0xbf, 0x73, 0x0a, 0xa4, 0xa6, 0x94, 0xd9, 0x87, 0x77, 0x9e, 0xb3, 0x82, 0x19,
        0x96, 0x27, 0x79, 0x91, 0x24, 0xb9, 0xb0, 0xf5, 0x99, 0x19, 0x6d, 0xc7, 0x06, 0x79, 0x6e, 0x4a,
        0xc5, 0x7c, 0x31, 0x82, 0xeb, 0x7f, 0x3d, 0x23, 0xc8, 0xb1, 0xfe, 0x43, 0x00, 0x57, 0xff, 0x75,
        0xcf, 0x6c, 0xc2, 0xfa, 0x0f, 0xc9, 0x40, 0x91, 0x82, 0x62, 0x74, 0xd6, 0x7f, 0xaa, 0x24, 0xa5,
        0xe4, 0x74, 0xfe, 0x1f, 0xd7, 0x7f, 0x82, 0xd0, 0xd6, 0x3f, 0x0b, 0x5b, 0xd8, 0xd1, 0x93, 0xa0,
        0xfa, 0xbf, 0x5f, 0xff, 0x29, 0x09, 0xae, 0xff, 0x03, 0xc1, 0xd5, 0xbf, 0x5d, 0xff, 0x99, 0x49,
        0x73, 0xc2, 0x72, 0xae, 0xca, 0x22, 0x2d, 0x74, 0x32, 0x2f, 0x0c, 0x9f, 0x13, 0x41, 0x19, 0x13,
        0x69, 0xae, 0x4a, 0x51, 0x64, 0x09, 0xcf, 0x92, 0xf8, 0xe3, 0x7f, 0x46, 0x38, 0xde, 0xff, 0x06,
        0x03, 0x58, 0xfd, 0xb7, 0xa9, 0xd5, 0x2f, 0x9b, 0xb0, 0xfe, 0x43, 0x32, 0x50, 0xa4, 0xa0, 0x18,
        0x9d, 0xf5, 0xbf, 0x7e, 0xfe, 0x15, 0x73, 0xce, 0xff, 0x69, 0xa6, 0x01, 0xb0, 0xfe, 0x03, 0xd0,
        0xd6, 0x7f, 0x9c, 0x7b, 0x20, 0x02, 0xea, 0xff, 0xe1, 0xfc, 0x6f, 0xdc, 0xff, 0x0f, 0x42, 0x5b,
        0xff, 0x8d, 0xc9, 0xbf, 0xc4, 0x8f, 0x11, 0xa6, 0x3f, 0x6f, 0xf4, 0xaf, 0xe7, 0xff, 0x50, 0xff,
        0xf1, 0x39, 0xd5, 0xdf, 0xb9, 0x06, 0xd8, 0x7e, 0xe4, 0x26, 0x31, 0x99, 0xa2, 0x52, 0xa5, 0x74,
        0x9e, 0x29, 0x65, 0xe6, 0x34, 0x27, 0x8a, 0x70, 0x5a, 0x48, 0xc2, 0xd3, 0x84, 0x93, 0x9c, 0x13,
        0x5a, 0x14, 0x24, 0x49, 0xc5, 0x6c, 0x51, 0x9c, 0xeb, 0xd9, 0xbc, 0xfd, 0x9f, 0x70, 0xf7, 0xff,
        0xda, 0x01, 0x20, 0xee, 0xff, 0x00, 0x21, 0xa0, 0xff, 0xa3, 0xc9, 0x35, 0xfd, 0x5f, 0x93, 0x5a,
        0xc1, 0xd9, 0x84, 0xcd, 0xe0, 0xc8, 0xc4, 0x10, 0xc9, 0x17, 0xc3, 0xd3, 0xff, 0xd9, 0x67, 0xdd,
        0xf1, 0x7f, 0x26, 0x14, 0x9e, 0xff, 0x08, 0x43, 0x5c, 0xff, 0x3f, 0xdf, 0x3f, 0xf8, 0xfd, 0x9f,
        0xba, 0xfe, 0x2f, 0x08, 0x9e, 0xff, 0x00, 0x42, 0x88, 0xff, 0xa7, 0xc0, 0xfe, 0x5f, 0x7f, 0x35,
        0x16, 0x80, 0x71, 0x89, 0x22, 0x92, 0x27, 0x46, 0xa7, 0xff, 0xd7, 0x9e, 0xaf, 0x84, 0xe3, 0xff,
        0x36, 0x0c, 0xee, 0xff, 0x03, 0xe1, 0xcc, 0xfd, 0xbf, 0xb5, 0xa2, 0x65, 0x71, 0x13, 0xef, 0x3a,
        0x08, 0x9f, 0xff, 0x53, 0xe9, 0xde, 0xff, 0xce, 0x6d, 0x06, 0xa0, 0xff, 0x43, 0x10, 0x70, 0xff,
        0x8f, 0x1a, 0x62, 0xff, 0x47, 0xc9, 0x84, 0x56, 0x3e, 0x41, 0x4e, 0x54, 0x1a, 0x21, 0x46, 0xfd,
        0x50, 0x77, 0x9d, 0xff, 0x43, 0xd5, 0xc9, 0xfd, 0x2f, 0xaa, 0x9e, 0xff, 0x43, 0xff, 0x1f, 0x9f,
        0xbd, 0xfe, 0xa3, 0x5d, 0xfd, 0xd3, 0x50, 0xff, 0x3c, 0x82, 0xef, 0xff, 0xc3, 0xf9, 0x3f, 0x10,
        0x0e, 0xfa, 0x8f, 0x72, 0xf5, 0x4f, 0x43, 0x80, 0xfe, 0xdf, 0xdf, 0xff, 0x53, 0xdc, 0xff, 0x07,
        0x82, 0xab, 0x7f, 0xe4, 0xab, 0x7f, 0x1a, 0xbc, 0xfd, 0x9f, 0x76, 0xef, 0x7f, 0x54, 0xb6, 0x60,
        0x60, 0xff, 0x07, 0x41, 0xc0, 0xf9, 0xbf, 0x64, 0x48, 0xff, 0x87, 0x57, 0xff, 0x4c, 0x1b, 0x8f,
        0x4a, 0x51, 0x62, 0xf8, 0xfa, 0x3f, 0x62, 0x7f, 0xdf, 0x7e, 0xff, 0x4f, 0x04, 0xc5, 0xf9, 0x5f,
        0x10, 0xba, 0xfd, 0x3f, 0xce, 0x3d, 0x20, 0x5e, 0xff, 0x57, 0xce, 0xfb, 0x3f, 0x2a, 0x08, 0xc7,
        0xf1, 0x3f, 0x08, 0x01, 0xf7, 0xff, 0x5c, 0xeb, 0xff, 0x78, 0xf5, 0xcf, 0x04, 0x39, 0xab, 0x52,
        0xe4, 0x18, 0x01, 0xfe, 0xff, 0xb2, 0xfe, 0x43, 0x08, 0xf4, 0x7f, 0x10, 0x8e, 0xf4, 0x1f, 0xe3,
        0xea, 0x9f, 0x86, 0x80, 0xf1, 0xdf, 0x8b, 0xfe, 0xf5, 0x96, 0x00, 0x1c, 0xff, 0x01, 0x70, 0xaa,
        0x7f, 0xd4, 0xab, 0x7f, 0x1a, 0x02, 0xf4, 0xdf, 0x9f, 0xff, 0x4d, 0x35, 0xd7, 0x38, 0xff, 0x03,
        0xc2, 0x45, 0xfd, 0xe3, 0x5c, 0xfd, 0xd3, 0xe0, 0xed, 0xff, 0xb4, 0xf3, 0xfe, 0x9f, 0x4a, 0xa1,
        0xb1, 0xff, 0x03, 0x21, 0xa0, 0xff, 0x1b, 0xf4, 0xfa, 0x1f, 0xaf, 0xfe, 0x99, 0x36, 0xdd, 0x2a,
        0xc5, 0x89, 0xe1, 0xed, 0xff, 0xb8, 0x72, 0xde, 0xff, 0x13, 0x4a, 0xf0, 0xfc, 0x3f, 0x10, 0x7a,
        0xfa, 0xff, 0x55, 0xb3, 0x42, 0x3e, 0xff, 0x67, 0xe4, 0xe4, 0xfc, 0x17, 0xa5, 0xf0, 0xfc, 0x37,
        0x10, 0x02, 0xe6, 0x7f, 0xa3, 0xf9, 0x3f, 0x4e, 0x04, 0x4f, 0x87, 0xbe, 0x2a, 0x5d, 0x13, 0xc3,
        0xeb, 0xff, 0xc7, 0xf3, 0xbf, 0x62, 0xbf, 0xfe, 0x5f, 0x69, 0xf4, 0x7f, 0x08, 0x8e, 0xf4, 0xaf,
        0xcc, 0xdd, 0x38, 0x8b, 0x00, 0x02, 0xc6, 0x7f, 0xcf, 0xfb, 0xbf, 0x24, 0xaf, 0xf5, 0xc7, 0xf1,
        0xdf, 0xf8, 0xb4, 0xcb, 0xbc, 0xd9, 0x6c, 0x66, 0xbf, 0x47, 0x8f, 0xe1, 0x1d, 0xff, 0xb9, 0xeb,
        0xbf, 0x29, 0xa5, 0x5a, 0x63, 0xfd, 0x87, 0xa0, 0x7f, 0xfd, 0x97, 0xa1, 0xdb, 0xbf, 0x9b, 0x64,
        0xc2, 0xea, 0x3e, 0x6d, 0x46, 0x7a, 0xe4, 0x5b, 0x78, 0xea, 0xbf, 0x94, 0xf2, 0xe8, 0xfc, 0x37,
        0x5e, 0xdf, 0xff, 0xc5, 0x15, 0xc3, 0xf5, 0xdf, 0x20, 0xdc, 0x16, 0xa6, 0x32, 0x23, 0xc7, 0x08,
        0xab, 0xff, 0xf5, 0xfc, 0x3f, 0x97, 0x78, 0xfe, 0x3b, 0x0c, 0x8d, 0xfe, 0xed, 0x26, 0x60, 0x67,
        0xaa, 0xc7, 0x6d, 0x61, 0x9e, 0x3e, 0x67, 0x8b, 0x2f, 0xe5, 0x6e, 0x96, 0xef, 0xbe, 0x5e, 0x19,
        0xc3, 0x5b, 0xff, 0x95, 0x3b, 0xfe, 0x17, 0x9a, 0x63, 0xfd, 0x07, 0x21, 0x60, 0xfe, 0x97, 0x07,
        0xd6, 0xff, 0x26, 0xb3, 0x4e, 0x93, 0x09, 0x3b, 0x82, 0x29, 0x71, 0x49, 0xa5, 0x98, 0x31, 0x3a,
        0xeb, 0x3f, 0xe5, 0x8c, 0xba, 0xf3, 0xbf, 0x54, 0x73, 0x5c, 0xff, 0x0f, 0x83, 0xbb, 0xde, 0x6b,
        0xb5, 0x98, 0x97, 0xbb, 0x6a, 0xf6, 0xf7, 0xee, 0xf2, 0x77, 0x1a, 0x8c, 0xd7, 0xff, 0xa5, 0x3b,
        0xfe, 0x63, 0x5a, 0xe3, 0xfa, 0x5f, 0x10, 0x02, 0xf6, 0x7f, 0x85, 0xfa, 0x7f, 0x2b, 0x99, 0xd0,
        0xf5, 0xa7, 0xc9, 0x48, 0x8f, 0x7c, 0x8b, 0x4e, 0xff, 0x57, 0x5c, 0xda, 0x3f, 0x1e, 0xc6, 0x7f,
        0x6a, 0x7f, 0xff, 0x23, 0xc3, 0xf5, 0x5f, 0x08, 0x82, 0x20, 0x08, 0x82, 0x20, 0x08, 0x82, 0x20,
        0x08, 0x12, 0x8d, 0xff, 0x01, 0xe8, 0xf1, 0xe2, 0x42, 0x00, 0x40, 0x01, 0x00
    };

    // prepare pax-header tar
    ASSERT_EQ(0, ErofsTest::inflate(src_path, const_cast<unsigned char*>(tar_zipped), sizeof(tar_zipped)));

    // create device
    auto src_file = host_fs->open(src_path.c_str(), O_RDONLY, 0666);
    ASSERT_NE(nullptr, src_file);
    DEFER(delete src_file);
    auto fmeta = host_fs->open(fn_idx.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
    auto findex = host_fs->open(fn_meta.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
    LSMT::WarpFileArgs args(findex, fmeta, src_file);
    args.virtual_size = IMAGE_SIZE;
    auto wrap_file = create_warpfile(args, false);
    ASSERT_NE(wrap_file, nullptr);

    // create erofs image
    auto tar = new LibErofs(wrap_file, 4096, true);
    ASSERT_EQ(0, tar->extract_tar(src_file, true, true));
    delete tar;

    // setup erofs fs
    auto erofs_fs = create_erofs_fs(wrap_file, 4096);
    ASSERT_NE(erofs_fs, nullptr);
    DEFER(delete erofs_fs);

    // traverse the fs tree
    std::string res;
    std::string std_res = "sha256:4d7ad1fb36abd862a7caa9da01233aed7c762bbb8d900dc5baf60c5b1ddd8496";
    std::vector<string> items;
    items.emplace_back("/");
    while (!items.empty()) {
        std::string tmp = items.front();
        struct stat st;

        items.erase(items.begin());
        res += tmp;
        ASSERT_EQ(0, erofs_fs->stat(tmp.c_str(), &st));
        if (S_ISDIR(st.st_mode)) {
            auto dir = erofs_fs->opendir(tmp.c_str());
            while (dir->next()) {
                dirent *dent = dir->get();
                items.emplace_back(tmp + "/" + std::string(dent->d_name));
            }
            dir->closedir();
            delete dir;
        }
    }

    auto sha256_f = host_fs->open(sha256_path.c_str(), O_RDWR | O_CREAT | O_TRUNC);
    ASSERT_NE(sha256_f, nullptr);
    sha256_f->pwrite(res.c_str(), res.size(), 0);
    sha256_f->lseek(0, SEEK_SET);
    auto sha256file = new_sha256_file(sha256_f, false);
    ASSERT_STREQ(std_res.c_str(), sha256file->sha256_checksum().c_str());
    delete sha256_f;
    delete sha256file;
}

/* test for the internal ErofsCache */
typedef uint64_t        u64;
class ErofsCache {
public:
    ErofsCache(photon::fs::IFile *file, unsigned long int capacity):
    file(file), capacity(capacity)
    {}
    ~ErofsCache() {}
    ssize_t write_sector(u64 addr, char *buf);
    ssize_t read_sector(u64 addr, char *buf);
    int flush();
public:
    photon::fs::IFile *file;
    long unsigned int capacity;
    std::map<u64, struct liberofs_inmem_sector*>caches;
    std::set<u64> dirty;
};

/* helper functions for reading and writing photon files */
extern ssize_t erofs_read_photon_file(void *buf, u64 offset, size_t len,
                                      ErofsCache *cache);
extern ssize_t erofs_write_photon_file(const void *buf, u64 offset,
                                       size_t len, ErofsCache *cache);
class ErofsCacheTest: public ::testing::Test {
protected:
    std::string workdir = "/tmp/erofs_cache_test";
    std::string file_path = workdir + "/img_file";
    photon::fs::IFileSystem *host_fs;
    photon::fs::IFile *img_file;
    ErofsCache *cache;

    virtual void SetUp() override{
        /* prepare for workdir */
        host_fs = photon::fs::new_localfs_adaptor();
        ASSERT_NE(nullptr, host_fs);
        if (host_fs->access(workdir.c_str(), 0)) {
            ASSERT_EQ(host_fs->mkdir(workdir.c_str(), 0755), 0);
        }

        /* prepare for img_file */
        img_file = host_fs->open(file_path.c_str(), O_RDWR | O_CREAT | O_TRUNC,
                                 0666);
        ASSERT_NE(nullptr, img_file);

        /*
         * prepare for cache. here, we use a cache with a size of only
         * one sector to simulate a memory-constrained situation.
         */
        cache = new ErofsCache(img_file, 1);
        ASSERT_NE(nullptr, cache);
    }

    virtual void TearDown() override{
        ASSERT_NE(nullptr, host_fs);
        if (host_fs->access(file_path.c_str(), 0) == 0) {
            ASSERT_EQ(host_fs->unlink(file_path.c_str()), 0);
        }
        delete host_fs;
        delete img_file;
        delete cache;
    }
};

TEST_F(ErofsCacheTest, erofs_cache) {

#define SECTOR_SIZE 512ULL
#define HALF_SECTOR (SECTOR_SIZE / 2)
#define BIG_OFFSET ((1ULL << 32) - 1)
#define round_down_blk(addr) ((addr) & (~(SECTOR_SIZE - 1)))
#define round_up_blk(addr) (round_down_blk((addr) + SECTOR_SIZE - 1))

    char buffer[SECTOR_SIZE];
    char buffer_cmp[SECTOR_SIZE];

    /*
     * TC001
     * 1. write 0xff to [0, 512]
     * 2. write 0x00 to [256, 512]
     * 3. compare
     */
    memset(buffer, 0xff, SECTOR_SIZE);
    ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer, 0, SECTOR_SIZE,
                                                   cache));
    memset(buffer, 0x00, SECTOR_SIZE);
    ASSERT_EQ(HALF_SECTOR, erofs_write_photon_file(buffer, HALF_SECTOR,
                                                   HALF_SECTOR, cache));
    memset(buffer_cmp, 0xff, HALF_SECTOR);
    memset(buffer_cmp + HALF_SECTOR, 0x00, HALF_SECTOR);
    ASSERT_EQ(SECTOR_SIZE, erofs_read_photon_file(buffer, 0, SECTOR_SIZE,
                                                  cache));
    ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));

    /*
     * TC002
     * 1. write 0xff to [0, 1024]
     * 2. write 0x00 to [0, 512]
     * 3. flush, then read and compare
     */
    memset(buffer, 0xff, SECTOR_SIZE);
    ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer, 0, SECTOR_SIZE,
                                                   cache));
    ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer, SECTOR_SIZE,
                                                   SECTOR_SIZE, cache));
    memset(buffer, 0x00, SECTOR_SIZE);
    ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer, 0, SECTOR_SIZE,
                                                   cache));
    cache->flush();
    memset(buffer, 0x00, SECTOR_SIZE);
    ASSERT_EQ(SECTOR_SIZE, img_file->pread(buffer_cmp, SECTOR_SIZE, 0));
    ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
    memset(buffer, 0xff, SECTOR_SIZE);
    ASSERT_EQ(SECTOR_SIZE, img_file->pread(buffer_cmp, SECTOR_SIZE,
                                           SECTOR_SIZE));
    ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));

    /*
     * TC003
     * write 11 blocks, odd blocks contain
     * 0xff and even blocks contain 0x00
     */
    for (int i = 0; i < 11; i ++) {
        if (i & 1)
            memset(buffer, 0xff, SECTOR_SIZE);
        else
            memset(buffer, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer, SECTOR_SIZE * i,
                                                       SECTOR_SIZE, cache));
    }
    cache->flush();
    for (int i = 0; i < 11; i ++) {
        if (i & 1)
            memset(buffer_cmp, 0xff, SECTOR_SIZE);
        else
            memset(buffer_cmp, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_read_photon_file(buffer, SECTOR_SIZE * i,
                                                      SECTOR_SIZE, cache));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
        ASSERT_EQ(SECTOR_SIZE, img_file->pread(buffer, SECTOR_SIZE,
                                               SECTOR_SIZE * i));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
    }

    /*
     * TC 004
     * test for non-aligned blocks
     */
    for (int i = 0; i < 10; i ++) {
        if (i & 1)
            memset(buffer, 0xff, SECTOR_SIZE);
        else
            memset(buffer, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer,
                HALF_SECTOR +  SECTOR_SIZE * i, SECTOR_SIZE, cache));
    }
    cache->flush();
    for (int i = 0; i < 10; i ++) {
        if (i & 1)
            memset(buffer_cmp, 0xff, SECTOR_SIZE);
        else
            memset(buffer_cmp, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_read_photon_file(buffer,
                HALF_SECTOR + SECTOR_SIZE * i, SECTOR_SIZE, cache));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
        ASSERT_EQ(SECTOR_SIZE, img_file->pread(buffer, SECTOR_SIZE,
                                               HALF_SECTOR + SECTOR_SIZE * i));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
    }

    /*
     * TC 005
     * test for offset bigger than 2^32 (block-aligned)
     */
    for (int i = 0; i < 11; i ++) {
        if (i & 1)
            memset(buffer, 0xff, SECTOR_SIZE);
        else
            memset(buffer, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer,
                round_up_blk(BIG_OFFSET) + SECTOR_SIZE * i, SECTOR_SIZE, cache));
    }
    cache->flush();
    for (int i = 0; i < 11; i ++) {
        if (i & 1)
            memset(buffer_cmp, 0xff, SECTOR_SIZE);
        else
            memset(buffer_cmp, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_read_photon_file(buffer,
                round_up_blk(BIG_OFFSET) + SECTOR_SIZE * i, SECTOR_SIZE, cache));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
        ASSERT_EQ(SECTOR_SIZE, img_file->pread(buffer, SECTOR_SIZE,
                round_up_blk(BIG_OFFSET) + SECTOR_SIZE * i));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
    }

    /*
     * TC 006
     * test for offset bigger than 2^32 (non-aligned)
     */
    for (int i = 0; i < 10; i ++) {
        if (i & 1)
            memset(buffer, 0xff, SECTOR_SIZE);
        else
            memset(buffer, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_write_photon_file(buffer,
                BIG_OFFSET + SECTOR_SIZE * i, SECTOR_SIZE, cache));
    }
    cache->flush();
    for (int i = 0; i < 10; i ++) {
        if (i & 1)
            memset(buffer_cmp, 0xff, SECTOR_SIZE);
        else
            memset(buffer_cmp, 0x00, SECTOR_SIZE);
        ASSERT_EQ(SECTOR_SIZE, erofs_read_photon_file(buffer,
                BIG_OFFSET + SECTOR_SIZE * i, SECTOR_SIZE, cache));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
        ASSERT_EQ(SECTOR_SIZE, img_file->pread(buffer, SECTOR_SIZE,
                BIG_OFFSET + SECTOR_SIZE * i));
        ASSERT_EQ(0, memcmp(buffer, buffer_cmp, SECTOR_SIZE));
    }

#undef SECTOR_SIZE
#undef HALF_SECTOR
#undef BIG_OFFSET
#undef round_down_blk
#undef round_up_blk
}

/* test for building in clean and incremental mode */
class ErofsTestCleanIncremental: public ::testing::Test {
protected:
    photon::fs::IFileSystem *host_fs;
    std::string workdir = "/tmp/erofs_clean_incrementtal";
    /* layer0 */
    std::string layer0_src = workdir + "/layer0.tar";
    std::string layer0_idx = workdir + "/layer0.idx";
    std::string layer0_meta = workdir + "/layer0.meta";
    std::string layer0_content = workdir + "/layer0_content";
    /* layer1 */
    std::string layer1_src = workdir + "/layer1.tar";
    std::string layer1_idx = workdir + "/layer1.idx";
    std::string layer1_meta = workdir + "/layer1.meta";
    std::string layer1_content = workdir + "/layer1_content";

    virtual void SetUp() override{
        host_fs = photon::fs::new_localfs_adaptor();
        ASSERT_NE(nullptr, host_fs);
        if (host_fs->access(workdir.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->mkdir(workdir.c_str(), 0755));
        }
    }

    virtual void TearDown() override{
        ASSERT_NE(nullptr, host_fs);
        /* layer 0 */
        if (host_fs->access(layer0_src.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer0_src.c_str()));
        }
        if (host_fs->access(layer0_idx.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer0_idx.c_str()));
        }
        if (host_fs->access(layer0_meta.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer0_meta.c_str()));
        }
        if (host_fs->access(layer0_content.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer0_content.c_str()));
        }

        /* layer 1 */
        if (host_fs->access(layer1_src.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer1_src.c_str()));
        }
        if (host_fs->access(layer1_idx.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer0_idx.c_str()));
        }
        if (host_fs->access(layer1_meta.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer0_meta.c_str()));
        }
        if (host_fs->access(layer1_content.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->unlink(layer1_content.c_str()));
        }

        if (host_fs->access(workdir.c_str(), 0) != 0) {
            ASSERT_EQ(0, host_fs->rmdir(workdir.c_str()));
        }
        delete host_fs;
    }

    int traverse_fs(photon::fs::IFileSystem *fs, photon::fs::IFile *out) {
        std::vector<string> items;

        items.emplace_back("/");
        while (!items.empty()) {
            std::string tmp = items.front();
            struct stat st;

            out->write(tmp.c_str(), tmp.size());
            items.erase(items.begin());
            if (fs->stat(tmp.c_str(), &st))
                LOG_ERRNO_RETURN(0, -1, "fail to stat file `", tmp);
            /* handle dirs */
            if (S_ISDIR(st.st_mode)) {
                auto dir = fs->opendir(tmp.c_str());
                do {
                    dirent *dent = dir->get();
                    items.emplace_back(tmp + "/" + std::string(dent->d_name));
                } while (dir->next());
                dir->closedir();
                delete dir;
            } else if (S_ISREG(st.st_mode)) { /* handle regular files */
                photon::fs::IFile *file;
                size_t left = st.st_size;
                off_t offset = 0;
                char buf[4096];
                int len;

                file = fs->open(tmp.c_str(), O_RDONLY);
                if (!file)
                    LOG_ERRNO_RETURN(0, -1, "fail to open file `", tmp);
                while (left > 0) {
                    len = std::min((size_t)4096, left);
                    if ((len = file->pread(buf, len, offset)) < 0) {
                            LOG_ERROR_RETURN(0, len, "fail to pread file `", tmp);
                    } else if (len == 0)
                            LOG_ERROR_RETURN(0, len, "fail to pread file `", tmp);
                    if (out->write(buf, len) != len)
                        LOG_ERRNO_RETURN(0, -1, "fail to write content to out file");
                    left -= len;
                    offset += len;
                }
                delete file;
            }
        }
        return 0;
    }
};

/*
 * There are two layers, whose structures are:
 *
 * layer0 (root)
 * ├── [ 4.0K]  dir1
 * │   ├── [ 4.0K]  dir1_1.txt
 * │   ├── [ 8.0K]  dir1_2.txt
 * │   └── [ 4.9K]  dir1_3.txt
 * ├── [ 4.0K]  dir2
 * │   ├── [ 4.0K]  dir2_1.txt
 * │   ├── [ 8.0K]  dir2_2.txt
 * │   └── [ 4.9K]  dir2_3.txt
 * ├── [ 4.0K]  dir3
 * │   ├── [ 4.0K]  dir3_1.txt
 * │   ├── [ 8.0K]  dir3_2.txt
 * │   └── [ 4.9K]  dir3_3.txt
 * └── [  512]  dirx (** a regular file **)
 *
 * layer1 (root)
 * ├── [ 4.0K]  dir1
 * │   ├── [ 8.0K]  dir1_1.txt
 * │   └── [  512]  dir1_4.txt
 * ├── [ 4.0K]  dir3
 * │   └── [  36K]  dir3_3.txt
 * ├── [ 4.0K]  dir4
 * │   ├── [ 4.0K]  dir4_1.txt
 * │   └── [  32K]  dir4_2.txt
 * ├── [ 4.0K]  dirx (** a directory **)
 * │   ├── [ 4.9K]  dirx_1.txt
 * │   ├── [ 8.0K]  dirx_2.txt
 * │   └── [  32K]  dirx_3.txt
 * └── [    0]  .wh.dir2
 */
TEST_F(ErofsTestCleanIncremental, clean_incremental_mode) {
    /* test for the clean mode */
    static const unsigned char layer0_zipped[482] = {
        0x1f, 0x8b, 0x08, 0x08, 0x26, 0x47, 0x40, 0x67, 0x00, 0x03, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x30,
        0x2e, 0x74, 0x61, 0x72, 0x00, 0xed, 0xdd, 0xd1, 0x6a, 0xdb, 0x30, 0x14, 0x06, 0x60, 0x3f, 0x4a,
        0x9e, 0x20, 0xb5, 0x64, 0x4b, 0x7a, 0x9c, 0x91, 0x6d, 0x37, 0xbd, 0x2a, 0x64, 0x19, 0xf4, 0xf1,
        0x67, 0x3b, 0x81, 0xb9, 0x85, 0x75, 0x85, 0xce, 0x92, 0xd7, 0x7c, 0xdf, 0x85, 0x13, 0xec, 0x40,
        0x1c, 0x8e, 0xac, 0xc0, 0x8f, 0x7c, 0x7c, 0x7c, 0xe8, 0x36, 0xd7, 0x4f, 0x4a, 0x4a, 0xcb, 0xeb,
        0xe4, 0xf5, 0xeb, 0xf2, 0x3e, 0x8c, 0x25, 0xf6, 0xfd, 0x18, 0x42, 0x18, 0xa6, 0xfd, 0xa5, 0xf4,
        0xb1, 0x3b, 0xa4, 0xed, 0x4f, 0xad, 0xeb, 0x7e, 0xfe, 0xb8, 0x9c, 0xce, 0x87, 0x43, 0x77, 0x7e,
        0x7a, 0xba, 0xbc, 0xf5, 0xb9, 0xbf, 0x1d, 0xff, 0x4f, 0x1d, 0x1f, 0xbe, 0x3f, 0x9e, 0x9f, 0xb7,
        0xfd, 0x8e, 0xb9, 0xc0, 0x79, 0x1c, 0xff, 0x54, 0xff, 0xb0, 0xaa, 0x7f, 0x9f, 0x4b, 0xec, 0xa6,
        0x3d, 0xa9, 0x0c, 0xdd, 0xa1, 0xdf, 0xf6, 0xb4, 0xae, 0xee, 0xbc, 0xfe, 0x27, 0xee, 0xda, 0x72,
        0xfd, 0xc7, 0x6d, 0xff, 0x04, 0xde, 0x39, 0xff, 0x87, 0x3c, 0x5d, 0xf7, 0xb9, 0x4f, 0xcb, 0xf5,
        0x9f, 0xb2, 0xf9, 0xbf, 0x86, 0x5b, 0xfd, 0xe7, 0xcd, 0x97, 0xe1, 0x78, 0x79, 0xde, 0xe2, 0x37,
        0xbe, 0x3d, 0xff, 0x87, 0xb9, 0xee, 0xaf, 0xea, 0x1f, 0xc7, 0xe9, 0xb0, 0xf9, 0xbf, 0x82, 0xaf,
        0x00, 0x00, 0x00, 0x00, 0xc0, 0xe6, 0x5a, 0xe5, 0x7f, 0xeb, 0xfc, 0x37, 0x36, 0xc9, 0x7f, 0xe3,
        0x8b, 0xfc, 0x3f, 0xe5, 0x32, 0xe7, 0xbf, 0x43, 0x29, 0xf2, 0xdf, 0x1a, 0x5a, 0x8f, 0x7b, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xe3, 0xd6, 0xeb, 0x3f, 0x42, 0x9b, 0xfb, 0xff, 0x5e,
        0xae, 0xff, 0x48, 0x61, 0x59, 0xff, 0x91, 0xb3, 0xf5, 0x1f, 0x35, 0xb4, 0x1e, 0x7f, 0x00, 0x00,
        0x00, 0xc0, 0xf6, 0x96, 0xfc, 0x67, 0xd8, 0x51, 0xff, 0xaf, 0x32, 0x2c, 0xfd, 0xbf, 0xf2, 0xa8,
        0xff, 0x57, 0x0d, 0xb7, 0xfa, 0xcf, 0x9b, 0x5d, 0xe4, 0x7f, 0x79, 0xb8, 0xdd, 0xff, 0x95, 0xe4,
        0x7f, 0x35, 0x7c, 0x03, 0x00, 0x00, 0x00, 0x3e, 0xbd, 0x75, 0xfe, 0xb3, 0x8b, 0xfe, 0xef, 0x4b,
        0xfe, 0x17, 0xc7, 0x5e, 0xff, 0x9f, 0x2a, 0x5a, 0x8f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x07,
        0xad, 0xf2, 0xbf, 0x75, 0xfe, 0xdb, 0xae, 0xff, 0x7b, 0xf8, 0x9d, 0xff, 0xa6, 0x51, 0xff, 0xf7,
        0x8a, 0x5a, 0x8f, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0x68, 0xbd, 0x00,
        0x81, 0xa6, 0x96, 0xf5, 0x3f, 0x61, 0x27, 0xfd, 0xdf, 0x62, 0x4e, 0x7d, 0x89, 0xd7, 0xfe, 0x6f,
        0x51, 0xff, 0xb7, 0x1a, 0x6e, 0xf5, 0x9f, 0x37, 0xbb, 0xe8, 0xff, 0x36, 0x8c, 0xfd, 0xf5, 0xf9,
        0x0f, 0xbd, 0xf5, 0x5f, 0x35, 0x9c, 0x00, 0x00, 0x00, 0x80, 0x4f, 0x6f, 0x9d, 0xff, 0xec, 0xa1,
        0xff, 0xdb, 0x18, 0xcb, 0xb5, 0xff, 0x9b, 0xfc, 0xa7, 0x8a, 0xd6, 0xe3, 0x0f, 0x00, 0x00, 0x00,
        0x00, 0xee, 0x41, 0xab, 0xfc, 0x6f, 0x9d, 0xff, 0xb6, 0xe9, 0xff, 0x16, 0xca, 0x64, 0x95, 0xff,
        0x5e, 0x9f, 0xff, 0x11, 0xf4, 0x7f, 0xab, 0xa2, 0xf5, 0xb8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x3e, 0xac, 0xf5, 0xf2, 0x03, 0xa0, 0xa1, 0x5f, 0xeb, 0xed, 0xa4, 0x5a, 0x00, 0xf0,
        0x00, 0x00
    };

    // prepare layer0 tar
    ASSERT_EQ(0, ErofsTest::inflate(layer0_src,
                                    const_cast<unsigned char*>(layer0_zipped),
                                    sizeof(layer0_zipped)));

    // create device
    auto layer0_src_file = host_fs->open(layer0_src.c_str(), O_RDONLY, 0666);
    ASSERT_NE(nullptr, layer0_src_file);
    DEFER(delete layer0_src_file);
    auto layer0_findex = host_fs->open(layer0_idx.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
    auto layer0_fmeta = host_fs->open(layer0_meta.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
    LSMT::WarpFileArgs layer0_args(layer0_findex, layer0_fmeta, layer0_src_file);
    layer0_args.virtual_size = IMAGE_SIZE;
    auto layer0_erofs_device = create_warpfile(layer0_args, false);
    ASSERT_NE(layer0_erofs_device, nullptr);
    DEFER(delete layer0_erofs_device);

    // create erofs image
    auto layer0_tar = new LibErofs(layer0_erofs_device, 4096, false);
    ASSERT_EQ(0, layer0_tar->extract_tar(layer0_src_file, true, true));
    delete layer0_tar;

    // setup erofs fs
    auto erofs_fs_layer0 = create_erofs_fs(layer0_erofs_device, 4096);
    ASSERT_NE(erofs_fs_layer0, nullptr);

    // traverse the fs tree
    std::string layer0_sha256_std = "sha256:6af847069dbebf41654dbb4f39de074e1d593eae3050b21eaedf09a2d53494f7";
    auto layer0_out = host_fs->open(layer0_content.c_str(), O_RDWR | O_CREAT | O_TRUNC);
    ASSERT_NE(nullptr, layer0_out);
    ASSERT_EQ(0, traverse_fs(erofs_fs_layer0, layer0_out));
    layer0_out->lseek(0, SEEK_SET);
    auto layer0_sha256file = new_sha256_file(layer0_out, false);
    ASSERT_STREQ(layer0_sha256_std.c_str(), layer0_sha256file->sha256_checksum().c_str());
    delete layer0_out;
    delete layer0_sha256file;
    delete erofs_fs_layer0;

    /* test for the incremental mode */
    static const unsigned char layer1_zipped[720] = {
        0x1f, 0x8b, 0x08, 0x08, 0x67, 0x4c, 0x40, 0x67, 0x00, 0x03, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x31,
        0x2e, 0x74, 0x61, 0x72, 0x00, 0xed, 0xdb, 0xc1, 0x6e, 0xa3, 0x3a, 0x14, 0x06, 0x60, 0x3f, 0x0a,
        0x4f, 0x40, 0x6c, 0x63, 0xcc, 0xe3, 0x54, 0xd5, 0xcd, 0x62, 0xba, 0x8a, 0x44, 0xa9, 0x26, 0x8f,
        0x7f, 0x09, 0x8d, 0x66, 0x3a, 0xa9, 0xda, 0xce, 0x86, 0x90, 0x4e, 0xbe, 0x6f, 0x61, 0x23, 0x40,
        0xc2, 0xe8, 0x27, 0x5e, 0x1c, 0x9d, 0xb4, 0xbb, 0xb0, 0xba, 0x38, 0x1b, 0xfa, 0x7e, 0x99, 0x67,
        0x97, 0xf3, 0x72, 0x9c, 0xca, 0x90, 0x63, 0xec, 0x6a, 0x9f, 0x4f, 0xf7, 0x0d, 0x43, 0xea, 0x43,
        0xd3, 0xaf, 0xbf, 0xb4, 0x10, 0x5e, 0x9e, 0xa7, 0xc7, 0xb1, 0x69, 0xc2, 0x78, 0x38, 0x4c, 0x9f,
        0xdd, 0xf7, 0xd5, 0xf5, 0x6f, 0xaa, 0xdd, 0xed, 0x9f, 0xc6, 0xe3, 0xba, 0x1f, 0xc1, 0xdf, 0xe7,
        0x5f, 0x6a, 0xcc, 0x35, 0xc4, 0x14, 0x6b, 0x8d, 0xf2, 0xbf, 0x86, 0x73, 0xfe, 0xa7, 0xe1, 0x21,
        0xb7, 0xd3, 0x71, 0x8d, 0x77, 0x3c, 0x05, 0x5c, 0x4b, 0xf9, 0x20, 0xff, 0x39, 0xf6, 0xd8, 0xfd,
        0xfa, 0xfd, 0xd7, 0x21, 0xcf, 0xf9, 0xe7, 0x9a, 0x52, 0x68, 0xe2, 0x0a, 0x6b, 0x79, 0xe7, 0xce,
        0xf3, 0xdf, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x82, 0xad, 0x5b, 0x10, 0xd8,
        0xd0, 0xdb, 0xfe, 0x9f, 0x6e, 0x8b, 0xfe, 0x9f, 0xb4, 0x0c, 0xbf, 0xfa, 0x7f, 0x86, 0x14, 0x97,
        0xfe, 0x9f, 0xf9, 0xb2, 0xfe, 0x9f, 0x2b, 0xd8, 0x7a, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x9b, 0x10, 0xb8, 0x67, 0xed, 0x6e,
        0xff, 0x34, 0x1e, 0x97, 0xe1, 0x21, 0xb5, 0xd3, 0x71, 0x5a, 0xe1, 0x19, 0x71, 0x56, 0x4b, 0x59,
        0xe6, 0xd9, 0xc5, 0x9c, 0x52, 0x4d, 0x31, 0xa4, 0x32, 0xe4, 0x18, 0xbb, 0x5a, 0x4b, 0x1f, 0x62,
        0xca, 0x35, 0x95, 0xd0, 0xc4, 0x15, 0xd6, 0xf2, 0xce, 0xcb, 0xf3, 0xf4, 0x38, 0x36, 0x4d, 0x18,
        0x0f, 0x87, 0x4f, 0xdf, 0xfd, 0xab, 0xeb, 0xdf, 0xd4, 0xd6, 0xdb, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0xdc, 0x83, 0xad, 0xea, 0x7f, 0x4b, 0xfd, 0xb7, 0xdb, 0xad, 0xfa, 0x8c, 0x53, 0x95, 0x77, 0xe8,
        0xfb, 0x0f, 0xea, 0xbf, 0xaf, 0xc7, 0xa9, 0x0c, 0xa9, 0x76, 0xb1, 0x96, 0x61, 0x3e, 0x9f, 0x62,
        0x5f, 0x73, 0x68, 0xfa, 0x55, 0x57, 0x75, 0x76, 0xe7, 0xf5, 0xdf, 0x73, 0xfe, 0xa7, 0xe1, 0xa1,
        0xdb, 0xa2, 0xfe, 0x9f, 0xe6, 0x4f, 0x63, 0x48, 0x17, 0xf9, 0xe7, 0x92, 0x93, 0xfa, 0xff, 0x35,
        0xfc, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x0a, 0xb7, 0xa1, 0xdd, 0xed, 0x9f, 0xc6, 0xb4, 0x5b, 0xf5,
        0x19, 0x71, 0x36, 0xf4, 0xfd, 0x32, 0xcf, 0x2e, 0xe7, 0xe5, 0x38, 0x95, 0x21, 0xd5, 0x3c, 0xd4,
        0x3e, 0xe6, 0x10, 0x53, 0xec, 0x6b, 0x0e, 0x4d, 0xbf, 0xea, 0xaa, 0xce, 0x5e, 0x9e, 0xa7, 0xc7,
        0xb1, 0x69, 0xc2, 0x78, 0x38, 0x4c, 0x9f, 0xdd, 0xf7, 0xd5, 0xf5, 0x6f, 0xea, 0x9c, 0xff, 0x69,
        0x78, 0x48, 0xed, 0x74, 0x5c, 0xe3, 0x1d, 0x4f, 0x01, 0xd7, 0x52, 0x3e, 0xc8, 0x3f, 0xff, 0x91,
        0x7f, 0x29, 0x75, 0xce, 0x3f, 0x97, 0x98, 0x42, 0x13, 0x57, 0x58, 0xcb, 0x3b, 0x77, 0x9e, 0xff,
        0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xed, 0xbd, 0xed, 0xff, 0x28, 0x9b, 0xf4,
        0x7f, 0xc4, 0xf4, 0xbe, 0xff, 0x27, 0x77, 0x43, 0xd1, 0xff, 0x71, 0x0d, 0x5b, 0x7f, 0x7f, 0x6c,
        0x6b, 0xf9, 0xfd, 0x97, 0x1b, 0xe9, 0xff, 0xeb, 0x62, 0x9d, 0xf7, 0x80, 0xd7, 0xfe, 0xbf, 0x41,
        0xff, 0xdf, 0x35, 0x9c, 0xf3, 0x3f, 0x0d, 0x1b, 0xf5, 0xff, 0x9d, 0xb6, 0xff, 0xf4, 0x3b, 0xff,
        0xd8, 0xd9, 0xff, 0xaf, 0x68, 0x0f, 0x00, 0x00, 0x00, 0xfc, 0xfb, 0xb6, 0x2e, 0x40, 0xb0, 0xa9,
        0xb7, 0xf5, 0xbf, 0xbc, 0x45, 0xfd, 0x2f, 0xc5, 0x3f, 0xeb, 0x7f, 0xa9, 0x7f, 0xfd, 0xff, 0x6f,
        0x54, 0xff, 0xbb, 0x86, 0xad, 0xb7, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x09, 0x81, 0x7b, 0xd6, 0xee, 0xda, 0x9f, 0x3f, 0xda,
        0xfd, 0xd3, 0x98, 0xd7, 0x7b, 0x46, 0x9c, 0xd5, 0x52, 0x96, 0x79, 0x76, 0x39, 0x2f, 0xc7, 0xa9,
        0x0c, 0xa9, 0x76, 0xb1, 0x76, 0xc3, 0x7c, 0x3e, 0xa5, 0x54, 0x4b, 0x68, 0xe2, 0x7a, 0x4b, 0xfa,
        0xed, 0xe5, 0x79, 0x7a, 0x1c, 0x9b, 0x26, 0x8c, 0x87, 0xc3, 0xf4, 0xd9, 0x7d, 0x5f, 0x5d, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x1b, 0xf2, 0x3f, 0xe2, 0x43, 0x75, 0xe6, 0x00, 0x30, 0x02, 0x00
    };

    // prepare layer1 tar
    ASSERT_EQ(0, ErofsTest::inflate(layer1_src,
                                    const_cast<unsigned char*>(layer1_zipped),
                                    sizeof(layer1_zipped)));
    // create device
    auto layer1_src_file = host_fs->open(layer1_src.c_str(), O_RDONLY, 0666);
    ASSERT_NE(nullptr, layer1_src_file);
    DEFER(delete layer1_src_file);
    auto layer1_findex = host_fs->open(layer1_idx.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
    auto layer1_fmeta = host_fs->open(layer1_meta.c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);
    LSMT::WarpFileArgs layser1_args(layer1_findex, layer1_fmeta, layer1_src_file);
    auto layer1_erofs_device = create_warpfile(layser1_args, false);
    ASSERT_NE(layer1_erofs_device, nullptr);
    DEFER(delete layer1_erofs_device);

    // merge lower and upper
    LSMT::IFileRW *merged_view = stack_files(layer1_erofs_device, layer0_erofs_device, false, false);
    ASSERT_NE(nullptr, merged_view);

    // setup erofs fs
    auto layer1_tar = new LibErofs(merged_view, 4096, false);
    ASSERT_EQ(0, layer1_tar->extract_tar(layer1_src_file, true, false));
    delete layer1_tar;
    auto erofs_fs_layer1 = create_erofs_fs(merged_view, 4096);
    ASSERT_NE(erofs_fs_layer1, nullptr);

    // traverse the fs tree
    std::string layer1_sha256_std = "sha256:a57cc5bf4d47dbd098a4d019364bd9af559063d48b7033b7322147332c132b04";
    auto layer1_out = host_fs->open(layer1_content.c_str(), O_RDWR | O_CREAT | O_TRUNC);
    ASSERT_NE(nullptr, layer1_out);
    ASSERT_EQ(0, traverse_fs(erofs_fs_layer1, layer1_out));
    layer1_out->lseek(0, SEEK_SET);
    auto layer1_sha256file = new_sha256_file(layer1_out, false);
    ASSERT_STREQ(layer1_sha256_std.c_str(), layer1_sha256file->sha256_checksum().c_str());
    delete layer1_out;
    delete layer1_sha256file;
    delete erofs_fs_layer1;
}

int main(int argc, char **argv) {

    ::testing::InitGoogleTest(&argc, argv);
    photon::init(photon::INIT_EVENT_DEFAULT, photon::INIT_IO_DEFAULT);
    set_log_output_level(1);

    auto ret = RUN_ALL_TESTS();
    (void)ret;

    return 0;
}
